---
title: Data Grid - Server-side row grouping
---

# Data Grid - Server-side row grouping [<span class="plan-premium"></span>](/x/introduction/licensing/#premium-plan 'Premium plan')

Implement row grouping with server-side data in the Data Grid using the Data Source layer.

The Data Grid Premium's row grouping feature lets users create subsets of rows based on repeated column values or custom functions.
The Grid can render grouped rows from server-side data using the [Data Source layer](/x/react-data-grid/server-side-data/#the-solution-the-data-source-layer).

:::info
For row grouping on the client side, see [Row grouping (client side)](/x/react-data-grid/row-grouping/).
:::

The following demo uses autogenerated data from a dataset of commodities to simulate server-side row grouping.

```tsx
import * as React from 'react';
import {
  DataGridPremium,
  GridDataSource,
  GridGroupingColDefOverride,
  GridValidRowModel,
  useGridApiRef,
  useKeepGroupedColumnsHidden,
} from '@mui/x-data-grid-premium';
import { useMockServer } from '@mui/x-data-grid-generator';
import Button from '@mui/material/Button';

const groupingColDef: GridGroupingColDefOverride<GridValidRowModel> = {
  width: 250,
};

export default function ServerSideRowGroupingFullDataGrid() {
  const apiRef = useGridApiRef();

  const { fetchRows, editRow, columns, loadNewData } = useMockServer({
    rowGrouping: true,
    rowLength: 1000,
    dataSet: 'Commodity',
    maxColumns: 20,
    editable: true,
  });

  const dataSource: GridDataSource = React.useMemo(() => {
    return {
      getRows: async (params) => {
        const urlParams = new URLSearchParams({
          paginationModel: JSON.stringify(params.paginationModel),
          filterModel: JSON.stringify(params.filterModel),
          sortModel: JSON.stringify(params.sortModel),
          groupKeys: JSON.stringify(params.groupKeys),
          groupFields: JSON.stringify(params.groupFields),
        });
        const getRowsResponse = await fetchRows(
          `https://mui.com/x/api/data-grid?${urlParams.toString()}`,
        );
        return {
          rows: getRowsResponse.rows,
          rowCount: getRowsResponse.rowCount,
        };
      },
      updateRow: async (params) => {
        const syncedRow = await editRow(params.rowId, params.updatedRow);
        return syncedRow;
      },
      getGroupKey: (row) => row.group,
      getChildrenCount: (row) => row.descendantCount,
    };
  }, [fetchRows, editRow]);

  const initialState = useKeepGroupedColumnsHidden({
    apiRef,
    initialState: {
      rowGrouping: {
        model: ['commodity', 'status'],
      },
      columns: {
        columnVisibilityModel: {
          id: false,
        },
      },
    },
  });

  return (
    <div style={{ width: '100%' }}>
      <Button onClick={loadNewData}>Regenerate Data</Button>

      <div style={{ height: 450, position: 'relative' }}>
        <DataGridPremium
          columns={columns}
          dataSource={dataSource}
          apiRef={apiRef}
          initialState={initialState}
          showToolbar
          groupingColDef={groupingColDef}
        />
      </div>
    </div>
  );
}

```

:::info
The Data Source demos use a `useMockServer` utility function to simulate server-side data fetching.
In a real-world scenario you would replace this with your own server-side data-fetching logic.

Open the Info section of your browser console to see the requests being made and the data being fetched in response.
:::

## Prerequisites

Server-side row grouping is an extension of its client-side counterpart, so we recommend reviewing [Row grouping (client side)](/x/react-data-grid/row-grouping/) to understand the underlying data structures and core implementation before proceeding.

To be able to dynamically load row-grouping data from the server, including lazy-loading of children, you must create a Data Source and pass the `dataSource` prop to the Data Grid, as detailed in the [Server-side data overview](/x/react-data-grid/server-side-data/).

## Implementating server-side row grouping

The Data Source requires the following props to implement row grouping:

- `getGroupKey()`: Returns the group key for the row.
- `getChildrenCount()`: Returns the number of children for the row; returns `-1` if there are children present but the count is not available.

```tsx
const customDataSource: GridDataSource = {
  getRows: async (params) => {
    // Fetch the data from the server
  },
  getGroupKey: (row) => {
    // Return the group key for the row, e.g. `name`
    return row.name;
  },
  getChildrenCount: (row) => {
    // Return the number of children for the row
    return row.childrenCount;
  },
};
```

In addition to `groupKeys`, the `getRows()` callback receives a `groupFields` parameter.
This corresponds to the current `rowGroupingModel`.
Use `groupFields` on the server to group the data for each `getRows()` call.

```tsx
const getRows: async (params) => {
  const urlParams = new URLSearchParams({
    // Example: JSON.stringify(['20th Century Fox', 'James Cameron'])
    groupKeys: JSON.stringify(params.groupKeys),
    // Example: JSON.stringify(['company', 'director'])
    groupFields: JSON.stringify(params.groupFields),
  });
  const getRowsResponse = await fetchRows(
    // Server should group the data based on `groupFields` and
    // extract the rows for the nested level based on `groupKeys`.
    `https://mui.com/x/api/data-grid?${urlParams.toString()}`,
  );
  return {
    rows: getRowsResponse.rows,
    rowCount: getRowsResponse.rowCount,
  };
}
```

With the required props and parameters in place, server-side row grouping should now be implemented in your Data Grid, as shown in the demo below:

```tsx
import * as React from 'react';
import {
  DataGridPremium,
  GridDataSource,
  useGridApiRef,
  useKeepGroupedColumnsHidden,
} from '@mui/x-data-grid-premium';
import { useMockServer } from '@mui/x-data-grid-generator';
import Button from '@mui/material/Button';

export default function ServerSideRowGroupingDataGrid() {
  const apiRef = useGridApiRef();

  const { fetchRows, columns } = useMockServer({
    rowGrouping: true,
  });

  const dataSource: GridDataSource = React.useMemo(() => {
    return {
      getRows: async (params) => {
        const urlParams = new URLSearchParams({
          paginationModel: JSON.stringify(params.paginationModel),
          filterModel: JSON.stringify(params.filterModel),
          sortModel: JSON.stringify(params.sortModel),
          groupKeys: JSON.stringify(params.groupKeys),
          groupFields: JSON.stringify(params.groupFields),
        });
        const getRowsResponse = await fetchRows(
          `https://mui.com/x/api/data-grid?${urlParams.toString()}`,
        );
        return {
          rows: getRowsResponse.rows,
          rowCount: getRowsResponse.rowCount,
        };
      },
      getGroupKey: (row) => row.group,
      getChildrenCount: (row) => row.descendantCount,
    };
  }, [fetchRows]);

  const initialState = useKeepGroupedColumnsHidden({
    apiRef,
    initialState: {
      rowGrouping: {
        model: ['company', 'director'],
      },
    },
  });

  return (
    <div style={{ width: '100%' }}>
      <Button
        onClick={() => {
          apiRef.current?.dataSource.cache.clear();
        }}
      >
        Clear cache
      </Button>

      <div style={{ height: 400, position: 'relative' }}>
        <DataGridPremium
          columns={columns}
          dataSource={dataSource}
          apiRef={apiRef}
          initialState={initialState}
        />
      </div>
    </div>
  );
}

```

:::warning
Server-side row grouping does not support the [`colDef.groupingValueGetter()`](/x/react-data-grid/row-grouping/#using-groupingvaluegetter-for-complex-grouping-value) method because the computation is performed on the server.
Use `dataSource.getGroupKey()` to compute the group key for the row instead.
:::

## Error handling

If an error occurs during a `getRows()` call, the Data Grid displays an error message in the row group cell.
`onDataSourceError()` is also triggered with an error containing the params described in [Server-side data overviewâ€”Error handling](/x/react-data-grid/server-side-data/#error-handling).

The demo below renders a custom Snackbar component to display an error message when the requests fail, which you can simulate using the checkbox and the **Refetch rows** button at the top.

```tsx
import * as React from 'react';
import {
  DataGridPremium,
  GridDataSource,
  useGridApiRef,
  useKeepGroupedColumnsHidden,
  GridGetRowsResponse,
  GridGetRowsError,
} from '@mui/x-data-grid-premium';
import { useMockServer } from '@mui/x-data-grid-generator';
import Snackbar from '@mui/material/Snackbar';
import Button from '@mui/material/Button';
import Checkbox from '@mui/material/Checkbox';
import FormControlLabel from '@mui/material/FormControlLabel';
import { alpha, styled, darken, lighten, Theme } from '@mui/material/styles';

export default function ServerSideRowGroupingErrorHandling() {
  const apiRef = useGridApiRef();
  const [rootError, setRootError] = React.useState<string>();
  const [childrenError, setChildrenError] = React.useState<string>();
  const [shouldRequestsFail, setShouldRequestsFail] = React.useState(false);

  const { fetchRows, columns } = useMockServer<GridGetRowsResponse>(
    {
      rowGrouping: true,
    },
    {},
    shouldRequestsFail,
  );

  const dataSource: GridDataSource = React.useMemo(() => {
    return {
      getRows: async (params) => {
        const urlParams = new URLSearchParams({
          paginationModel: JSON.stringify(params.paginationModel),
          filterModel: JSON.stringify(params.filterModel),
          sortModel: JSON.stringify(params.sortModel),
          groupKeys: JSON.stringify(params.groupKeys),
          groupFields: JSON.stringify(params.groupFields),
        });
        const getRowsResponse = await fetchRows(
          `https://mui.com/x/api/data-grid?${urlParams.toString()}`,
        );
        return {
          rows: getRowsResponse.rows,
          rowCount: getRowsResponse.rowCount,
        };
      },
      getGroupKey: (row) => row.group,
      getChildrenCount: (row) => row.descendantCount,
    };
  }, [fetchRows]);

  const initialState = useKeepGroupedColumnsHidden({
    apiRef,
    initialState: {
      rowGrouping: {
        model: ['company', 'director'],
      },
    },
  });

  return (
    <div style={{ width: '100%' }}>
      <div style={{ display: 'flex', justifyContent: 'space-between' }}>
        <Button
          onClick={() => {
            setRootError('');
            apiRef.current?.dataSource.fetchRows();
          }}
        >
          Refetch rows
        </Button>
        <FormControlLabel
          control={
            <Checkbox
              checked={shouldRequestsFail}
              onChange={(event) => setShouldRequestsFail(event.target.checked)}
            />
          }
          label="Make the requests fail"
        />
      </div>
      <div style={{ height: 400, position: 'relative' }}>
        <DataGridPremium
          columns={columns}
          dataSource={dataSource}
          onDataSourceError={(error) => {
            if (error instanceof GridGetRowsError) {
              if (!error.params.groupKeys || error.params.groupKeys.length === 0) {
                setRootError(error.message);
              } else {
                setChildrenError(
                  `${error.message} (Requested level: ${error.params.groupKeys.join(' > ')})`,
                );
              }
            }
          }}
          dataSourceCache={null}
          apiRef={apiRef}
          initialState={initialState}
        />
        {rootError && <ErrorOverlay error={rootError} />}
        <Snackbar
          open={!!childrenError}
          autoHideDuration={3000}
          onClose={() => setChildrenError('')}
          message={childrenError}
        />
      </div>
    </div>
  );
}

function getBorderColor(theme: Theme) {
  if (theme.palette.mode === 'light') {
    return lighten(alpha(theme.palette.divider, 1), 0.88);
  }
  return darken(alpha(theme.palette.divider, 1), 0.68);
}

const StyledDiv = styled('div')(({ theme: t }) => ({
  position: 'absolute',
  zIndex: 10,
  fontSize: '0.875em',
  top: 0,
  height: '100%',
  width: '100%',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  borderRadius: '4px',
  border: `1px solid ${getBorderColor(t)}`,
  backgroundColor: t.palette.background.default,
}));

function ErrorOverlay({ error }: { error: string }) {
  if (!error) {
    return null;
  }
  return <StyledDiv>{error}</StyledDiv>;
}

```

## Group expansion

Group expansion with server-side row grouping works similarly to how it's described in the [client-side row grouping documentation](/x/react-data-grid/row-grouping/#group-expansion).
The difference is that the data is not initially available and is fetched automatically after the Data Grid is mounted based on the `defaultGroupingExpansionDepth` and `isGroupExpandedByDefault()` props in a waterfall manner.

The following demo uses `defaultGroupingExpansionDepth={-1}` to expand all groups by default.

```tsx
import * as React from 'react';
import {
  DataGridPremium,
  GridDataSource,
  useGridApiRef,
  useKeepGroupedColumnsHidden,
} from '@mui/x-data-grid-premium';
import { useMockServer } from '@mui/x-data-grid-generator';
import Button from '@mui/material/Button';

export default function ServerSideRowGroupingGroupExpansion() {
  const apiRef = useGridApiRef();

  const { fetchRows, columns } = useMockServer({
    rowGrouping: true,
  });

  const dataSource: GridDataSource = React.useMemo(() => {
    return {
      getRows: async (params) => {
        const urlParams = new URLSearchParams({
          paginationModel: JSON.stringify(params.paginationModel),
          filterModel: JSON.stringify(params.filterModel),
          sortModel: JSON.stringify(params.sortModel),
          groupKeys: JSON.stringify(params.groupKeys),
          groupFields: JSON.stringify(params.groupFields),
        });
        const getRowsResponse = await fetchRows(
          `https://mui.com/x/api/data-grid?${urlParams.toString()}`,
        );
        return {
          rows: getRowsResponse.rows,
          rowCount: getRowsResponse.rowCount,
        };
      },
      getGroupKey: (row) => row.group,
      getChildrenCount: (row) => row.descendantCount,
    };
  }, [fetchRows]);

  const initialState = useKeepGroupedColumnsHidden({
    apiRef,
    initialState: {
      rowGrouping: {
        model: ['company'],
      },
    },
  });

  return (
    <div style={{ width: '100%' }}>
      <Button
        onClick={() => {
          apiRef.current?.dataSource.cache.clear();
        }}
      >
        Clear cache
      </Button>

      <div style={{ height: 400, position: 'relative' }}>
        <DataGridPremium
          columns={columns}
          dataSource={dataSource}
          apiRef={apiRef}
          initialState={initialState}
          defaultGroupingExpansionDepth={-1}
        />
      </div>
    </div>
  );
}

```

## API

- [DataGrid](/x/api/data-grid/data-grid/)
- [DataGridPro](/x/api/data-grid/data-grid-pro/)
- [DataGridPremium](/x/api/data-grid/data-grid-premium/)
